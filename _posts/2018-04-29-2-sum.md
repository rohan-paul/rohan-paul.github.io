---
layout: post
title: Two-Sum Challenges in JavaScript
comments: true
author: Rohan Paul
categories: JavaScript
use_math : true
---
<img src="/images/fulls/2-sum-3-sum.jpg" class="fit image">


**2-Sum Problem with JavaScript**

A quite popular challenge specially for Developer Interviews is what I stumbled upon in a **[Leetcode Problem](https://leetcode.com/problems/two-sum/description/)**.  This is a variation of the classic **[subset sum problem](https://en.wikipedia.org/wiki/Subset_sum_problem)** in computer science. 

**Problems Statement - Given an array of integers, return indices of the two numbers such that they add up to a specific target.**

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

**My Brute Force Solution**

<p data-height="354" data-theme-id="0" data-slug-hash="JvEKpo" data-default-tab="js" data-user="rohanpaul" data-embed-version="2" data-pen-title="2-Sum-Broot-Force-Blog" class="codepen">See the Pen <a href="https://codepen.io/rohanpaul/pen/JvEKpo/">2-Sum-Broot-Force-Blog</a> by Rohan Paul (<a href="https://codepen.io/rohanpaul">@rohanpaul</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

The above check all the combinations by looping through each element ``x`` and find if there is another value that equals to target  ``target−x``. 

**Time complexity : O(n^2)**

​​For each element, we try to find its complement by looping through the rest of array which takes ``O(n)`` time. Therefore, the time complexity is ``O(n^2)`` . The space complexity is constant because it doesn't need any temporary buffer to store the data. 


**Slightly Improved version - Alternative-1**

<p data-height="307" data-theme-id="0" data-slug-hash="ergzVX" data-default-tab="js" data-user="rohanpaul" data-embed-version="2" data-pen-title="2-sum-Alt-2-Blog" class="codepen">See the Pen <a href="https://codepen.io/rohanpaul/pen/ergzVX/">2-sum-Alt-2-Blog</a> by Rohan Paul (<a href="https://codepen.io/rohanpaul">@rohanpaul</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>


**Best Solution in O(n) time**

<p data-height="343" data-theme-id="0" data-slug-hash="rvjLQE" data-default-tab="js" data-user="rohanpaul" data-embed-version="2" data-pen-title="2-sum-BestO(n)-Solution-Blog" class="codepen">See the Pen <a href="https://codepen.io/rohanpaul/pen/rvjLQE/">2-sum-BestO(n)-Solution-Blog</a> by Rohan Paul (<a href="https://codepen.io/rohanpaul">@rohanpaul</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

Here, under the first for loop, I am doing a ``numsObject[num] = i`` which means, I am assigning the given array element value to be the key in the key-value pair of the object / associative-array that I created. And the index-no of that element (``i``) of that array to be the value in the key-value object.

Then in the second for loop, will check with ``hasOwnPropery()`` if the key exists. And here the key that I am looking for will be the will be the compliment ``(target - x)``.

In this way, the look up time is reduced from ``O(n)`` to ``O(1)`` by trading space for speed. A hash table is built to achieve this. It supports fast look up in near constant time. I say "near" because if a collision occurred, a look up could degenerate to ``O(n)`` time. But look up in hash table should be amortized ``O(1)`` time as long as the hash function was chosen carefully. Since hash table has average access time ``O(1)``, and we only access the array once. The time complexity of this solution is ``O(n)``. Since we use the hash table as a temporary buffer, at worst case we need additional O(n) storage.

